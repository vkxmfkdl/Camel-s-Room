"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var path = require("path");
var semver = require("semver");
var lodash_1 = require("lodash");
var filesys_1 = require("./filesys");
/**
 * @param  {string} packageJsonPath
 * @returns IDependencyMap
 */
function createDependencyMap(packageFile) {
    var deps = lodash_1.get(packageFile, "dependencies", {});
    var devDeps = lodash_1.get(packageFile, "devDependencies", {});
    var dependencyMap = {
        deps: toDependencies(deps),
        devDeps: toDependencies(devDeps)
    };
    return dependencyMap;
}
exports.createDependencyMap = createDependencyMap;
;
/**
 * @param  {{}} object
 * @returns IDependency
 */
function toDependencies(object) {
    return Object.keys(object)
        .map(function (packageName) { return ({
        name: packageName,
        version: object[packageName]
    }); });
}
exports.toDependencies = toDependencies;
;
/**
 * @param  {string} version
 * @returns string
 */
function parseVersion(version) {
    // Tests for whether the version starts with ~ (tilde) or ^ (caret)
    if (/^[~^]/.test(version)) {
        return version.substring(1);
    }
    return extractVersionFromUrl(version);
}
exports.parseVersion = parseVersion;
;
/**
 * @param  {string} version
 * @returns string
 */
function extractVersionFromUrl(version) {
    // Regex for checking whether this version references a git ssh url
    var regex = /(?:git|ssh|https?|git@[-\w.]+):(\/\/)?(.*?)(\.git)(\/?|\#[-\d\w._]+?)$/;
    if (regex.test(version)) {
        // If a version number is present, then return that version number, else return 'Unknown'
        var i = version.indexOf('.git#v');
        if (i > 0) {
            return version.substring(i + 6);
        }
        else {
            return 'Unknown';
        }
    }
    return version;
}
exports.extractVersionFromUrl = extractVersionFromUrl;
/**
 * @param  {IDependency} dep
 * @returns IPackageDescriptor
 */
function dependencyToPackageDescriptor(dep) {
    var packageDescriptor = {
        name: dep.name,
        definedVersion: extractVersionFromUrl(dep.version),
        parsedDefinedVersion: parseVersion(dep.version),
        installedVersion: null,
        installed: false,
        locked: semver.clean(extractVersionFromUrl(dep.version)) !== null
    };
    return packageDescriptor;
}
exports.dependencyToPackageDescriptor = dependencyToPackageDescriptor;
;
/**
 * @param  {IDependencyMap} depMap
 * @returns IPackageDescriptorMap
 */
function dependencyMapToPackageDescriptorMap(depMap) {
    var deps = depMap.deps, devDeps = depMap.devDeps;
    var map = {
        deps: deps.map(dependencyToPackageDescriptor),
        devDeps: devDeps.map(dependencyToPackageDescriptor)
    };
    return map;
}
exports.dependencyMapToPackageDescriptorMap = dependencyMapToPackageDescriptorMap;
;
/**
 * @param  {IPackageDescriptor} descriptor
 * @param  {string} modulesPath
 * @returns IPackageDescriptor
 */
function packageDescriptorCheckInstall(descriptor, modulesPath) {
    var packagePath = path.resolve(modulesPath, descriptor.name, 'package.json');
    var installed = filesys_1.fileExists(packagePath);
    if (!installed) {
        return descriptor;
    }
    var pkg = require(packagePath);
    descriptor.installed = true;
    descriptor.installedVersion = pkg.version;
    return descriptor;
}
exports.packageDescriptorCheckInstall = packageDescriptorCheckInstall;
;
/**
 * @param  {IPackageDescriptorMap} map
 * @param  {string} modulesPath
 * @returns IPackageDescriptorMap
 */
function packageDescriptorMapCheckInstall(map, modulesPath) {
    var deps = map.deps, devDeps = map.devDeps;
    var newMap = {
        deps: deps.map(function (m) { return packageDescriptorCheckInstall(m, modulesPath); }),
        devDeps: devDeps.map(function (m) { return packageDescriptorCheckInstall(m, modulesPath); }),
    };
    return newMap;
}
exports.packageDescriptorMapCheckInstall = packageDescriptorMapCheckInstall;
;
/**
 * @param  {string} version
 * @param  {string} expected
 * @returns boolean
 */
function isMatchingVersion(version, expected) {
    return version === expected;
}
exports.isMatchingVersion = isMatchingVersion;
;
